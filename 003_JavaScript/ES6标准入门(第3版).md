# ES6标准入门

## 一.ECMAScript简介

1. ES6转ES5
   + Babel转码器
     + 配置文件.babelrc，放在项目根目录，用来设置转码规则和插件
     + babel-cli 命令行转码
     + babel-node命令，babel-cli工具自带的命令
     + babel-register：此模块改写了require命令，在使用require加载文件时会先用babel进行转码
     + babel-core：调用babel的Api进行转码
     + babel-polyfill：Babel默认只对新的JavaScript句法进行转码，而不会对新的Api进行转码，例如Iterator、Generator等，若需要对这些Api进行转码，则需要使用babel-polyfill
     + babel与其他工具配合(即先用babel进行前置转码)
       1. ESLint
          + `npm install --save-dev eslint babel-eslint`
          + 在项目根目录创建配置文件.eslintrc，加入parser字段...
       2. Mocha
          + 这是一个测试框架
   + Traceur转码器

## 二.let & const

### 1. let

1. 使用let声明的变量被绑定在了声明时所在的代码块
   + for循环
   + 不存在变量提升，只有先声明才能使用，否则报错
2. 暂时性死区
   + ES6规定，若区块中存在let和const命令，则此区块对这些命令声明的变量从一开始就形成封闭作用域，只要在声明之前使用这些变量就会报错
   + 在代码块内，使用let命令声明变量之前的区域，可以认为是暂时性死区
   + 本质：只要进入当前作用域，所要使用的变量就已经存在，但不可获取，只有声明变量后才可以获取和使用该变量
3. 在同一作用域内不允许重复声明同一个变量

### 2.块级作用域

1. ES5只有全局作用域和函数作用域，没有块级作用域，导致的问题有
   + 内层变量会覆盖外层变量
   + 用来计数的循环变量泄漏为全局变量
2. let实际上为JS新增了块级作用域
3. 块级作用域的出现使得立即执行匿名函数不再必要了
4. 在ES5规范中，函数不能在块级作用域中声明，只能在顶层作用域和函数作用域中声明，但浏览器为了兼容没有遵守这点
   + 在ES6中，允许在块级作用域中声明函数，但在块级作用域外不可引用
5. do表达式
   + 本质上，块级作用域就是一个语句，将多个操作封装在一起，没有返回值，为了有返回值，可以使用do表达式，这只是一个提案。

### 3.const